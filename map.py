# Defines the Map class, which is used to represent the map of the world.
# The map is a 2D array of integers, where each integer represents a type of tile:
# 0: Empty
# 1: Obstacle
# 2: Cleaned
# Initially, there are no cleaned tiles.

# The Mpa class provides a generate radom map function, which generates a random map
# The map is generated by choosing random outlines for the border and the obstacles
# The map is then filled in with the fill_map function, which fills in the empty spaces
# with the correct tiles

# The Map also supports a collision detection function, which checks if a given position
# is colliding with an obstacle or the border of the map. This takes a rotated rectangle
# as input, which is used to represent the sweeper. A first pass is done to check if the
# axis aligned bounding box of the rectangle is colliding with the map. If it is, then
# a second pass is done to check if the rotated rectangle is colliding with the map.

from typing import Tuple, List
from shapely.geometry import Polygon, Point, LineString
from random_shape import get_random_shapely_outline
from metrics import get_patch_of_line
import numpy as np
import random
import pygame

class Map:

    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.grid = np.zeros((width, height), dtype=np.int8)
        self.cleaning_path = []

    def init_random(self):
        # Call generate_random with random parameters
        self.generate_random(
            nb_obstacles=random.randint(5, 10),
            avg_size_obstacles=0.2 * self.width,
            var_size_obstacles=0.1 * self.width
        )


    def generate_random(self, nb_obstacles, avg_size_obstacles, var_size_obstacles):
        # First fill the map with obstacles
        self.grid = np.ones((self.width, self.height), dtype=np.int8)

        # Generate random border
        border = get_random_shapely_outline(n=8, center=(self.width / 2, self.height / 2), min_width=self.width * 0.75,
                                            max_width=self.width * 1.25, min_height=self.height * 0.75, max_height=self.height * 1.25, edgy=0.5)
        self.fill_polygon(border, 0)

        # Generate random obstacles
        for i in range(nb_obstacles):
            # Choose random position
            empty_tiles = self.get_empty_tiles()
            pos = empty_tiles[random.randint(0, len(empty_tiles) - 1)]

            # Generate random obstacle
            avg_width = max(0.5*avg_size_obstacles, min(2*avg_size_obstacles, random.normalvariate(avg_size_obstacles, var_size_obstacles)))
            avg_height = max(0.5*avg_size_obstacles, min(2*avg_size_obstacles, random.normalvariate(avg_size_obstacles, var_size_obstacles)))
            min_width = 0.8 * avg_width
            max_width = 1.2 * avg_width
            min_height = 0.8 * avg_height
            max_height = 1.2 * avg_height
            obstacle = get_random_shapely_outline(n=8, center=(pos[0], pos[1]), min_width=min_width, max_width=max_width, min_height=min_height, max_height=max_height, edgy=0.5)
            self.fill_polygon(obstacle, 1)

    def fill_map(self, border: Polygon, obstacles: List[Polygon]):
        # Fill in border
        self.fill_polygon(border, 1)

        # Fill in obstacles
        for obstacle in obstacles:
            self.fill_polygon(obstacle, 1)

    def apply_cleaning(self, cur_pos):
        # Get the line between the two positions
        self.cleaning_path.append(cur_pos)
        if len(self.cleaning_path) >= 2:
            patch = get_patch_of_line(self.cleaning_path, width=5, resolution=16)
            # If polygon is not empty, fill it
            if not patch.is_empty:
                count = self.fill_polygon(patch, 2)
                self.cleaning_path = [self.cleaning_path[-1]]
                return count
        return 0

    def fill_polygon(self, polygon: Polygon, value: int):
        # Get bounding box
        min_x = max(0, int(polygon.bounds[0]))
        min_y = max(0, int(polygon.bounds[1]))
        max_x = min(self.width, int(polygon.bounds[2]))
        max_y = min(self.height, int(polygon.bounds[3]))

        # Fill in polygon
        count = 0
        for x in range(min_x, max_x):
            for y in range(min_y, max_y):
                if self.grid[x, y] != value and polygon.contains(Point(x, y)):
                    self.grid[x, y] = value
                    count += 1
        return count

    def check_collision(self, rectangle: np.ndarray) -> bool:
        # Convert the coordinates to integers
        x_min, y_min = np.floor(rectangle.min(axis=0)).astype(int)
        x_max, y_max = np.ceil(rectangle.max(axis=0)).astype(int)
        
        # Check if the rectangle is completely outside the grid
        if x_max < 0 or y_max < 0 or x_min >= self.grid.shape[0] or y_min >= self.grid.shape[1]:
            return False
        
        # Check if the rectangle is completely inside the grid
        if np.all(self.grid[x_min:x_max+1, y_min:y_max+1] == 0):
            return False 
        
        # Check if any obstacle cell is inside the rectangle (slow)
        # The rectangle is a numpy array of shape (4, 2)
        poly_rect = Polygon(rectangle)
        for x in range(x_min, x_max+1):
            for y in range(y_min, y_max+1):
                if self.grid[x, y] == 1:
                    # Check if the cell is inside the rectangle
                    if Point(x, y).within(poly_rect):
                        return True

        # No collision found
        return False

    def get_cleaned_tiles(self) -> List[Tuple[int, int]]:
        return np.argwhere(self.grid == 2)

    def get_obstacle_tiles(self) -> List[Tuple[int, int]]:
        return np.argwhere(self.grid == 1)

    def get_empty_tiles(self) -> List[Tuple[int, int]]:
        return np.argwhere(self.grid == 0)


    def display(self, screen: pygame.Surface, tile_size: int, sweeper = None, rerender: bool = False, cleaned_color: Tuple[int, int, int]=(0,255,0), obstacle_color: Tuple[int, int, int]=(0,0,0), empty_color: Tuple[int, int, int]=(255,255,255)):
        # Redraw everything
        if rerender:
            # Fill screen with obstacle color
            screen.fill(obstacle_color)
            
            # Display cleaned tiles
            for x, y in self.get_cleaned_tiles():
                pygame.draw.rect(screen, cleaned_color, pygame.Rect(x * tile_size, y * tile_size, tile_size, tile_size))

            # Display empty tiles
            for x, y in self.get_empty_tiles():
                pygame.draw.rect(screen, empty_color, pygame.Rect(x * tile_size, y * tile_size, tile_size, tile_size))
        else:
            # Update only around the sweeper
            # Get bounding box
            SWEEPER_SIZE_FACTOR = 1.5
            bounding_box = sweeper.get_bounding_box(factor=SWEEPER_SIZE_FACTOR)
            x_min, y_min = np.floor(bounding_box.min(axis=0)).astype(int)
            x_max, y_max = np.ceil(bounding_box.max(axis=0)).astype(int)
            for x in range(x_min, x_max+1):
                for y in range(y_min, y_max+1):
                    if self.grid[x, y] == 0:
                        pygame.draw.rect(screen, empty_color, pygame.Rect(x * tile_size, y * tile_size, tile_size, tile_size))
                    elif self.grid[x, y] == 1:
                        pygame.draw.rect(screen, obstacle_color, pygame.Rect(x * tile_size, y * tile_size, tile_size, tile_size))
                    elif self.grid[x, y] == 2:
                        pygame.draw.rect(screen, cleaned_color, pygame.Rect(x * tile_size, y * tile_size, tile_size, tile_size))


    def clean(self, rect: Polygon):
        # Get bounding box
        min_x = int(rect.bounds[0])
        min_y = int(rect.bounds[1])
        max_x = int(rect.bounds[2])
        max_y = int(rect.bounds[3])

        # Clean tiles
        for x in range(min_x, max_x):
            for y in range(min_y, max_y):
                if rect.contains(Point(x, y)):
                    self.grid[x, y] = 2


if __name__ == "__main__":
    # This is just to check out the map generation
    # Initiates a random map and displays it with pygame
    import sys

    # Initiate pygame
    pygame.init()
    screen = pygame.display.set_mode((800, 800))
    clock = pygame.time.Clock()

    # Initiate map
    map = Map(100, 100)
    map.init_random()

    # Main loop
    while True:
        # Check for events
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

        # Display map
        screen.fill((0, 0, 0))
        map.display(screen, 8)
        pygame.display.flip()

        # Tick clock
        clock.tick(60)

        # Selects a random empty tile and cleans it
        empty_tiles = map.get_empty_tiles()
        if len(empty_tiles) > 0:
            x, y = random.choice(empty_tiles)
            map.grid[x, y] = 2

    # Quit pygame
    pygame.quit()

